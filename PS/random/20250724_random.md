# 2025-07-24 골드 랜덤

## 1. [Fundraised](https://www.acmicpc.net/problem/9352) (Gold 5)
<details>
<summary>코드 보기</summary>
  
```cpp
void solve(){
    int n,m; ri(n, m);
    vi I(n),C(n),D(m + 1); ri(I); ri(C);
    D[0] = 0;
    for(int i = 0; i < n; i++){
        for(int j = C[i]; j <= m; j++){
            D[j] = max<int>(D[j], D[j - C[i]] + I[i]);
        }
    }
    int mx = 0;
    for(int j = 0; j <= m; j++){
        mx = max<int>(mx, D[j]);
    }
    po(mx);
}
```

</details>

D[i] : i원예산으로 만들 수 있는 중요도의 최대값으로 놓고 배낭 DB를 돌리면 된다.
물건을 무한대로 쓸 수 있는 것에 유의하자.

## 2. [화산쇄설류](https://www.acmicpc.net/problem/16569)(Gold 4)

<details>
  <summary>코드 보기</summary>
  
  ```cpp
int n,m,k,r, c;
int v[111][111], dist[111][111], vist[111][111], V[111][111];
queue<pii> T[10101];
bool Bound(int x, int y){ return x < 0 or x >= n or y < 0 or y >= n; }

void solve(){
    memset(dist, -1, sizeof(dist));
    memset(vist, -1, sizeof(vist));
    ri(n, m, k, r, c); --r,--c;
    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) ri(v[i][j]);
    for(int i = 0; i < k; i++){
        int a,b, t; ri(a, b, t); --a,--b;
        T[t].push({a, b});
        V[a][b] = 1;
    }
    queue<pii> q; 
    q.push({r, c}); dist[r][c] = 0;
    int mx = -INF, mxdist = INF;
    while(si(q)){
        auto [x, y] = q.front(); q.pop();
        auto t = dist[x][y];
        while(si(T[t])){
            auto [R, C] = T[t].front(); T[t].pop();
            vist[R][C] = t;
            for(int d = 0; d < 4; d++){
                auto nr = R + dx[d], nc = C + dy[d];
                if(Bound(nr, nc) or vist[nr][nc] != -1) continue;
                vist[nr][nc] = vist[R][C] + 1; T[vist[nr][nc]].push({nr, nc}); 
            }
        }
        mx = max<int>(mx, v[x][y]);
        for(int d = 0; d < 4; d++){
            auto nx = x + dx[d], ny = y + dy[d];
            if(Bound(nx, ny) or dist[nx][ny] != -1 or (vist[nx][ny] != -1)) continue;
            if(V[nx][ny]) continue;
            dist[nx][ny] = dist[x][y] + 1; q.push({nx, ny});
        }
    }
    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){
        if(v[i][j] == mx and dist[i][j] != -1 and !V[i][j]) mxdist = min<int>(mxdist, dist[i][j]);
    }
    po(mx, mxdist);
}
```

</details>
차분하게 BFS + 시뮬레이션을 돌리면 된다. 여러가지 방법이 있는데 현재 시간 T를 기준으로 큐 배열을 만들어서 화산쇄설류 먼저 전파하고 움직이는 식으로 구현하였다.
주의할 점은 화산쇄설류가 전파할 때 아직 분화하지 않는 화산을 지나갈 수 있다는 점.
