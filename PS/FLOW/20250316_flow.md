# 플로우 문제 풀이

- Date : 2025-03-16

[당일치기](https://www.acmicpc.net/problem/3713)
```cpp
void Sol(){
	int n; ri(n);
	struct I{ int h; char g; string music,sports; };
	vector<I> l, r;
	for(int i = 0; i < n; i++){
		int h; char c; string a,b; ri(h, c, a, b);
		(c == 'M' ? l : r).pb({h, c, a, b});
	}
	auto Check = [&](I& a, I& b) -> bool{
		return (abs(a.h - b.h) <= 40 and a.g != b.g and a.music == b.music and a.sports != b.sports);
	};
	vi match(n), par(n, -1);
	vvi g(n);
	auto add_edge = [&](int a, int b) -> void{ g[a].pb(b); };
	for(int i = 0; i < SZ(l); i++) for(int j = 0; j < SZ(r); j++){
		if(Check(l[i], r[j])) add_edge(i, j);
	}
	auto dfs = [&](int cur, auto&& dfs) -> int{
		for(const auto& nxt : g[cur]){
			if(match[nxt]) continue;
			match[nxt] = 1;
			if(par[nxt] == -1 or dfs(par[nxt], dfs)){
				par[nxt] = cur;
				return 1;
			}
		}
		return 0;
	};
	int res = 0;
	for(int i = 0; i < SZ(l); i++){
		fill(all(match), 0);
		res += dfs(i, dfs);
	}
	po(n - res);
}
```
전체 정점의 개수 - 매칭 수가 답이다(최소 정점 커버)
주어진 조건에서 반대의 조건을 모두 만족하는 식으로 간선을 연결해준 다음 매칭을 구하면 된다.
