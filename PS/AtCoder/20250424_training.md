# [AtCoder Daily Training ALL 2025/04/22 17:30start](https://atcoder.jp/contests/adt_all_20250422_2/tasks)

## 1. A - Count Takahashi
```python
n = int(input())
res = 0
for i in range(n):
  s = input()
  if s == "Takahashi": res += 1
print(res)
```

## 2. B - Weird Function
```python
def f(x):
  return x*x + 2*x + 3
n = int(input())
print(f(f(f(n) + n) + f(f(n))))
```

## 3. C - Glass and Mug
```cpp
void Main(){
    int n,m,k; ri(n, m, k);
    int l = 0,r = 0;
    for(int i = 0; i < n; i++){
        if(l == m) l = 0;
        else if(r == 0) r = k;
        else{
            int cur = min<int>(m - l, r);
            l += cur, r -= cur;
        }
    }
    po(l, r);
}
```
## 4. D - Get Closer
```cpp
void Main(){
    double a,b; ri(a, b);
    double x = hypot(a, b);
    po(a / x, b / x);
}
```
## 5. E - Yamanote Line Game
```cpp
void Main(){
    int n; ri(n);
    bitset<2222> vist;
    while(1){
        for(int i = 1; i <= (2*n + 1); i++){
            if(!vist[i]){
                cout << i << endl;
                vist[i] = 1;
                break;
            }
        }
        int res; ri(res);
        if(!res) break;
        vist[res] = 1;
    }
}
```

## 6. H - MST + 1
```cpp
int n,m,q;

struct unionfind{
    vi p;
    unionfind(int n):p(n + 1){
        iota(all(p), 0);
    }
    int Find(int x){ return x == p[x] ? x : p[x] = Find(p[x]); }
    bool Union(int a, int b){
        a = Find(a),b = Find(b);
        if(a == b) return 0;
        p[b] = a; return 1;
    }
};

template<size_t sz>
struct SegTree {
	vector<int> tree, lazy;
	SegTree() : tree(sz << 1, -INF), lazy(sz << 1, -INF) {}
	void Push(int node, int L, int R) {
		if (node < sz) for (const int nxt : { node << 1, node << 1 | 1}) lazy[nxt] = max<int>(lazy[nxt], lazy[node]);
		tree[node] = max<int>(tree[node], lazy[node]), lazy[node] = -INF;
	}
	void Update(int l, int r, int val, int node = 1, int L = 1, int R = sz) {
		Push(node, L, R);
		if (r < L || R < l) return;
		if (l <= L && R <= r) { lazy[node] = val, Push(node, L, R); return; }
		int mid = L + R >> 1;
		Update(l, r, val, node << 1, L, mid);
		Update(l, r, val, node << 1 | 1, mid + 1, R);
		tree[node] = max<int>(tree[node << 1], tree[node << 1 | 1]);
	}
	int Query(int l, int r, int node = 1, int L = 1, int R = sz) {
		Push(node, L, R);
		if (r < L || R < l) return -INF;
		if (l <= L && R <= r) return tree[node];
		int mid = L + R >> 1;
		return max<int>(Query(l, r, node << 1, L, mid), Query(l, r, node << 1 | 1, mid + 1, R));
	}
};

SegTree<1 << 18> ST;

const int sz = 1 << 18;
int Top[sz], Par[sz], Dep[sz], Sz[sz], In[sz], Out[sz], Cost[sz], temp;
vector<int> G[sz], Inp[sz];

void Connect(int a, int b){
    Inp[a].pb(b); Inp[b].pb(a);
}

void DFS(int cur = 1, int prev = -1){
    for(auto& nxt : Inp[cur]){
        if(nxt == prev) continue;
        G[cur].pb(nxt); 
        DFS(nxt, cur);
    }
}

void DFS1(int cur = 1){
    Sz[cur] = 1;
    for(auto& nxt : G[cur]){
        Dep[nxt] = Dep[cur] + 1; Par[nxt] = cur;
        DFS1(nxt); Sz[cur] += Sz[nxt];
        if(Sz[nxt] > Sz[G[cur][0]]) swap(nxt, G[cur][0]);
    }
}

void DFS2(int cur = 1){
    In[cur] = ++temp;
    for(const auto& nxt : G[cur]){
        Top[nxt] = (nxt == G[cur][0] ? Top[cur] : nxt);
        DFS2(nxt);
    }
    Out[cur] = temp;
}

void Init(){
    DFS(); DFS1(); DFS2(Top[1] = 1);
}

void Update(int a, int b, int c){
    for(; Top[a] != Top[b]; a = Par[Top[a]]){
        if(Dep[Top[a]] < Dep[Top[b]]) swap(a, b);
        ST.Update(In[Top[a]], In[a], c);
    }
    if(In[a] > In[b]) swap(a, b);
    ST.Update(In[a] + 1, In[b], c);
}

int Query(int a, int b){
    int ret = 0;
    for(; Top[a] != Top[b]; a = Par[Top[a]]){
        if(Dep[Top[a]] < Dep[Top[b]]) swap(a, b);
        ret = max<int>(ret, ST.Query(In[Top[a]], In[a]));
    }
    if(In[a] > In[b]) swap(a, b);
    ret = max<int>(ret, ST.Query(In[a] + 1, In[b]));
    return ret;
}

void Main(){
    ri(n, m, q);
    vector<ti3> E(m);
    for(auto& [c, a, b] : E) ri(a, b, c);
    sort(all(E));
    unionfind uf(n + 1);
    int mst = 0,cnt = 0;
    vector<ti3> have;
    for(const auto& [c, a, b] : E){
        if(uf.Union(a, b)){
            mst += c;
            Connect(a, b);
            have.push_back({c, a, b});
            if(++cnt == n - 1) break;
        }
    }
    //debug(mst);
    Init();
    for(const auto& [c, a, b] : have){
        Update(a, b, c);
        //debug(a, b, c);
    }
    while(q--){
        int a,b,c; ri(a, b, c);
        if(a == b) po("No");
        else{
            auto cur = Query(a, b);
            if(mst - cur + c < mst) po("Yes");
            else po("No");
        }
    }
}
```
H - MST + 1 : https://www.acmicpc.net/problem/10637 이 문제에서 최대값 쿼리로 바꾸고 처리

## 7. I - Distance Sums 2
```cpp
int n;
vi g[1 << 18];
int dist[1 << 18], sz[1 << 18];
bitset<202020> vist;

int DFS(int cur = 1){
	sz[cur] = 1;
	vist[cur] = 1;
	for(const auto& nxt : g[cur]){
		if(vist[nxt]) continue;
		dist[cur] += DFS(nxt);
		dist[cur] += sz[nxt];
		sz[cur] += sz[nxt];
	}
	return dist[cur];
}

void DFS2(int cur = 1){
	vist[cur] = 1;
	for(const auto& nxt : g[cur]){
		if(vist[nxt]) continue;
		dist[nxt] = dist[cur] + (n - sz[nxt] * 2);
		DFS2(nxt);
	}
}

void Main(){
    ri(n);
    for(int i = 1; i < n; i++){
        int a,b; ri(a, b);
        g[a].pb(b); g[b].pb(a);
    }
    DFS(1); vist.reset(); DFS2(1);
    for(int i = 1; i <= n; i++) po(dist[i]);
}
```
I - Distance Sums 2 : https://www.acmicpc.net/problem/7812 이 문제와 동일, tree dp rerooting tech [참고 링크](https://zlfn.space/blog/rerooting)
