# [BOJ] 2025년 11월 문제풀이 (3)

### 1. [<span style="color: #ec9a00;">G4</span>] [마지막 조별 시합](https://www.acmicpc.net/problem/2128)

- **tag** : bruteforce

알고리즘 문제의 종류의 범위가 수상하다. $2^D$의 복잡도로 비빌 수 있어보인다.

```cpp
int N, M, K, v[1011];

void solve(){
	ri(N, M, K);
	for(int i = 0; i < N; i++){
		int k; ri(k);
		while(k--){
			int x; ri(x); --x;
			v[i] |= (1 << x);
		}
	}
	int res = -1;
	for(int i = 0; i < (1 << M); i++){
		int cnt = 0;
		if(__builtin_popcount(i) == K){
			for(int j = 0; j < N; j++){
				cnt += ((v[j] & i) == v[j]);
			}
		}
		res = max<int>(res, cnt);
	}
	po(res);
}
```

### 2. [<span style="color: #435f7a;">S2</span>] [QWERTY 자판](https://www.acmicpc.net/problem/20914)

- **tag** : graphs, graph_traversal

직접 키보드를 보면서 인접한 키들을 이용해 그래프를 모델링한 뒤에 플로이드를 돌려서 해결하면 된다.
주의할 점은 모델링 할때 실수를 하면 안된다..

```cpp
int Q;
vvi D(222, vi(222, INF));

void solve(){
	for(char i = 'A'; i <= 'Z'; i++) D[i][i] = 0;
	D['Q']['W'] = D['W']['E'] = D['E']['R'] = D['R']['T'] = D['T']['Y'] = D['Y']['U'] = D['U']['I'] = D['I']['O'] = D['O']['P'] = 1;
	D['A']['S'] = D['S']['D'] = D['D']['F'] = D['F']['G'] = D['G']['H'] = D['H']['J'] = D['J']['K'] = D['K']['L'] = 1;
	D['Z']['X'] = D['X']['C'] = D['C']['V'] = D['V']['B'] = D['B']['N'] = D['N']['M'] = 1;
	D['Q']['A'] = D['A']['Z'] = D['W']['S'] = D['S']['X'] = D['E']['D'] = D['D']['C'] = D['R']['F'] = D['F']['V'] = D['T']['G'] = D['G']['B'] = D['Y']['H'] = D['H']['N'] = D['U']['J'] = D['J']['M'] = D['I']['K'] = D['O']['L'] = 1;
	D['W']['A'] = D['E']['S'] = D['S']['Z'] = D['R']['D'] = D['D']['X'] = D['T']['F'] = D['F']['C'] = D['Y']['G'] = D['G']['V'] = D['U']['H'] = D['H']['B'] = D['I']['J'] = D['J']['N'] = D['O']['K'] = D['K']['M'] = D['P']['L'] = 1;
	for(char i = 'A'; i <= 'Z'; i++) for(char j = 'A'; j <= 'Z'; j++){
		if(D[i][j] == 1) D[j][i] = 1;
	}
	for(char k = 'A'; k <= 'Z'; k++) for(char i = 'A'; i <= 'Z'; i++) for(char j = 'A'; j <= 'Z'; j++){
		D[i][j] = min<int>(D[i][j], D[i][k] + D[k][j]);
	}
	ri(Q);
	while(Q--){
		string s; ri(s);
		int res = 0;
		for(int i = 0; i + 1 < si(s); i++){
			res += D[s[i]][s[i + 1]];
		}
		po(res*2 + si(s));
	}
}
```

### 3. [<span style="color: #ec9a00;">G1</span>] [Rainbow Road Race](https://www.acmicpc.net/problem/22288)

- **tag** : dijkstra, bitmask, shortest_path

색깔의 종류가 7개밖에 없기 때문에 각각의 상태를 비트마스킹으로 표현해줄 수 있다.
`dist[N][1 << 7]; `이런식으로 방문 배열을 설정한 이후에 다익을 돌려서 해결해주자.

```cpp
int N, M;

void solve(){
	ri(N, M);
	vvi dist(N + 1, vi((1 << 7) + 1, INF));
	vector<vector<ti3>> g(N + 1);
	auto I = [&](char d) -> int{ return string("ROYGBIV").find(d); };
	for(int i = 0; i < M; i++){
		int a,b,c; char d; ri(a, b, c, d);
		int T = I(d);
		g[a].pb({c, T, b}); g[b].pb({c, T, a});
	}
	minpq<ti3> pq;
	pq.push({dist[1][0] = 0, 0, 1});
	while(si(pq)){
		auto [cdist, state, cur] = pq.top(); pq.pop();
		if(dist[cur][state] < cdist) continue;
		for(const auto& [cost, nT, nxt] : g[cur]){
			auto nstate = state | (1 << nT);
			if(dist[nxt][nstate] > cdist + cost){
				pq.push({dist[nxt][nstate] = cdist + cost, nstate, nxt});
			}
		}
	}
	po(dist[1][(1 << 7) - 1]);
}
```

### 4. [<span style="color: #435f7a;">S3</span>] [Waiter's Problem](https://www.acmicpc.net/problem/19358)

- **tag** : greedy, sorting

팁을 많이 주는 사람부터 처리하면 된다.

```cpp
void solve(){
	int n; ri(n);
	vi v(n); ri(v); sort(rall(v));
	int res = 0;
	for(int i = 0; i < n; i++){
		res += max<int>(v[i] - i, 0);
	}
	po(res);
}
```

### 5. [<span style="color: #ad5600;">B3</span>] [Snacks within 300 Yen](https://www.acmicpc.net/problem/32046)

- **tag** : implementation, simulation

하면 된다.

```cpp
void solve(){
	int N;
	while(cin >> N and N){
		int res = 0;
		for(int i = 0; i < N; i++){
			int x; ri(x);
			if(res + x < 301) res += x;
		}
		po(res);
	}
}
```

### 6. [<span style="color: #27e2a4;">P5</span>] [Bell Ringing](https://www.acmicpc.net/problem/11268)

- **tag** : constructive

브루트포스를 배울 때 나왔던 Steinhaus–Johnson–Trotter algorithm을 알고 있으면 쉽다. Steinhaus–Johnson–Trotter algorithm을 구현해주면 된다.

```cpp
void solve(){
	int n; ri(n);
	vi v(n),dir(n, -1); iota(all(v), 1);
	auto idx = [&]() -> int{
        int idx = -1;
        int best_val = -1;
        for (int i = 0; i < n; i++) {
            int d = dir[i];
            int j = i + d;
            if (j < 0 || j >= n) continue;
            if (v[i] > v[j]) {
				if (v[i] > best_val) {
                    best_val = v[i];
                    idx = i;
                }
            }
        }
        return idx;
    };
	for(int i = 0; i < n; i++) cout << v[i] << " ";
	cout << "\n";
	while(1){
		int k = idx();
		if(k == -1) break;
		int d = dir[k];
		int j = k + d;
		swap(v[k], v[j]);
        swap(dir[k], dir[j]);
		int nxt = v[j];
		for (int t = 0; t < n; ++t) {
            if (v[t] > nxt) dir[t] = -dir[t];
        }
		for(int i = 0; i < n; i++) cout << v[i] << " ";
		cout << "\n";
	}
}
```
