# 3847번 : Comparing answers

인접행렬에서 i -> j로 이동하는 경로의 길이가 K긴 경로의 개수를 구하는 문제는 인접행렬을 K번 거듭제곱하면 된다.
이 문제에선 시간제한이 10초이기 때문에 $O(N^3 / 8)$로 구현해주면 된다.

```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,avx,avx2,fma")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#include <bits/stdc++.h>
#include <ext/rope>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;

using ll = long long;
using pii = pair<int, int>;
using ti3 = tuple<int, int, int>;
using vi = vector<int>;
using vvi = vector<vi>;

constexpr int INF = int(1 << 30);
constexpr int NINF = -int(1 << 30);

int v[1111][1111], w[1111][1111], u[1111][1111];

void solve(){
	int n; while(cin >> n and n){
		for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){
			cin >> v[i][j]; w[j][i] = v[i][j];
		}
		for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) cin >> u[i][j];
		bool flag = 1;
		for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){
			int cur = 0;
			for(int k = 0; k < n; k++) cur += (v[i][k] * w[j][k]);
			if(u[i][j] != cur) flag = 0;
		}
		cout << (flag ? "YES" : "NO") << "\n";
	}
}

int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int t = 1;
	//cin >> t;
	for(int tc = 1; tc <= t; tc++) solve();
}
```
