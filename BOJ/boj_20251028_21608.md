# 21608번 : 상어 초등학교

상어 시리즈 중에 최고 순한맛
최적화 따윈 버리고 "하면 된다"

```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,avx,avx2,fma")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#include <bits/stdc++.h>
#include <ext/rope>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;

#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define fi first
#define se second
#define pb push_back
#define si(x) (int)x.size()

using ll = long long;
using pii = pair<int, int>;
using ti3 = tuple<int, int, int>;
using vi = vector<int>;
using vvi = vector<vi>;

const int PRECISION = 0;
const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};
const int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1}, ddy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
constexpr ll INF = 1LL << 30;
constexpr ll NINF = -INF;

int n;
array<int, 5> v[555];
bool vist[555][555];
int board[555][555];

bool bound(int x, int y){ return x < 0 or x >= n or y < 0 or y >= n; }

void solve(){
    cin >> n;
    for(int i = 0; i < n*n; i++) for(int j = 0; j < 5; j++) cin >> v[i][j];
    struct node{ int fav, cnt, x, y; };
    auto check_fav = [&](int x, int y, int a, int b, int c, int d){ return (board[x][y] == a or board[x][y] == b or board[x][y] == c or board[x][y] == d);};
    for(int idx = 0; idx < n * n; idx++){
        vector<node> cur;
        for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){
            if(vist[i][j]) continue;
            int cnt = 0, fav = 0;
            for(int d = 0; d < 4; d++){
                int nx = i + dx[d], ny = j + dy[d];
                if(bound(nx, ny)) continue;
                fav += (check_fav(nx, ny, v[idx][1], v[idx][2], v[idx][3], v[idx][4]));
                cnt += (!board[nx][ny]);
            }
            cur.push_back({fav, cnt, i, j});
        }
        sort(all(cur), [&](node& a, node& b){
            return (a.fav == b.fav ? (a.cnt == b.cnt ? (a.x == b.x ? a.y < b.y : a.x < b.x) : a.cnt > b.cnt) : a.fav > b.fav);
        });
        auto [fav, cnt, x, y] = cur[0];
        vist[x][y] = 1;
        board[x][y] = v[idx][0];
    }
    int res = 0;
    for(int idx = 0; idx < n * n; idx++){
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(board[i][j] == v[idx][0]){
                    int cnt = 0;
                    for(int d = 0; d < 4; d++){
                        int nx = i + dx[d], ny = j + dy[d];
                        if(bound(nx, ny)) continue;
                        cnt += (check_fav(nx, ny, v[idx][1], v[idx][2], v[idx][3], v[idx][4]));
                    }
                    int score = cnt;
                    if(cnt == 2) score = 10;
                    else if(cnt == 3) score = 100;
                    else if(cnt == 4) score = 1000;
                    res += score;
                }
            }
        }
    }
    cout << res << "\n";
}

void Main(){
    int t = 1; 
    //cin >> t;
    while(t--) solve();
    /* for(int tc = 1; tc <= t; tc++){
    cout << "Case #" << tc << ": "; solve();
    } */
}

int32_t main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cout.setf(ios::fixed); cout.precision(PRECISION);
    Main();
    return 0;
}
```
