# [BOJ] 2025년 11월 문제풀이 (1)

### 1. [<span style="color: #435f7a;">S2</span>] [Alice and Path](https://www.acmicpc.net/problem/23649)

주어진 격자 위에서 6번 이동한다면 동일한 위치로 오게 된다.
이걸 이용해서 문제를 해결하면 된다.

```cpp
void solve(){
	string s; ri(s);
	while(!s.empty()){
		for(int i = 0; i < 5; i++) cout << s.back();
		s.pop_back();
	}
}
```

### 2. [<span style="color: #ec9a00;">G4</span>] [육각수](https://www.acmicpc.net/problem/1229)

배낭문제처럼 풀면 된다.
$ D[x] = x를 만드는 데 필요한 육각수 최소 개수 $

```cpp
int n, sz = 1, w = 1;

void solve(){
	vi D(1'000'011, INF); D[0] = 0;
	while(sz < 1'000'011){
		for(int j = sz; j < 1'000'011; j++) D[j] = min<int>(D[j], D[j - sz] + 1);
		w += 4; sz += w;
	}
	ri(n); po(D[n]);
}
```

### 3. [<span style="color: #ad5600;">B3</span>] [Building Pyramids](https://www.acmicpc.net/problem/32585)

$N * (N + 1) * (N + 2) / 6$이 답이다.

```cpp
void solve(){
	int n; ri(n);
	po(n*(n + 1)*(n + 2) / 6);
}
```

### 4. [<span style="color: #ad5600;">B3</span>] [Append and Panic!](https://www.acmicpc.net/problem/33135)

이미 나온 글자면 건너뛰면 된다.

```cpp
int res;
string s;
bool vist[222];

void solve(){
	ri(s);
	res = si(s);
	for(const auto& i : s){
		if(vist[i]) continue;
		vist[i] = 1; res--;
	}
	po(res);
}
```

### 5. [<span style="color: #ad5600;">B3</span>] [どら焼き (Dorayaki)](https://www.acmicpc.net/problem/33164)

브루트포스로 다 봐도 된다.

```cpp
void solve(){
	int n,m; ri(n, m);
	vi v(n),w(m); ri(v); ri(w);
	int res = 0;
	for(int i = 0; i < n; i++) for(int j = 0; j < m; j++){
		res += (v[i] + w[j]) * max<int>(v[i], w[j]);
	}
	po(res);
}
```

### 6. [<span style="color: #435f7a;">S2</span>] [Constrained Permutations](https://www.acmicpc.net/problem/6913)

$M$개의 순서관계를 다 저장해놓고 $N!$을 전부 다 검사해서 개수를 카운팅해줘도 된다.

```cpp
void solve(){
	int n,m; ri(n, m);
	vp v(m); for(auto& [a, b] : v) ri(a, b);
	int res = 0;
	vi w(n); iota(all(w), 1);
	do{
		vi I(n + 1);
		for(int i = 0; i < n; i++){
			I[w[i]] = i + 1;
		}
		bool flag = 1;
		for(const auto& [a, b] : v){
			if(!(I[a] < I[b])){
				flag = 0;
				break;
			}
		}
		res += flag;
	}while(next_permutation(all(w)));
	po(res);
}
```

### 7. [<span style="color: #435f7a;">S3</span>] [Efficient Printing](https://www.acmicpc.net/problem/33532)

어떤 수에서 0의 개수를 세라는 건 소인수분해를 해서 2와 5의 개수 중 최소값을 구하라는 것과 동치이다.
소인수분해를 했을 때 2의 개수가 5의 개수보단 많으니 그냥 5의 개수에 대해서 조사하면 된다.

```cpp
void solve(){
	int n,k = 5, res = 0; ri(n);
	while(k <= n) res += (n / k), k *= 5;
	po(res);
}
```
