# 17038번 : The Great Revegetation (Silver)

정해와 비..슷?하게 푼건진 모르겠는데 2-sat느낌으로 모델링해서 품
N개의 정점을 분할해서 $[1, N], [N + 1, 2*N]$개의 정점을 가진 상태에서
유파를 써서 S인경우 같은 목초지에 있어야하기 때문에 $a->b, (n + a) -> (n + b)$로,
D인 경우 다른 목초지에 있어야하기 때문에 $(n + a) -> b, (n + b) -> a$로 묶어주면 된다.
주의 해야할 점이 마지막에 카운팅할 때 중복되는 경우(n + a -> b인 경우?)를 없애기 위해 $[1, N]$의 정점에 대해서 $i -> n + i$의 형태로 묶어준 이후에 카운팅을 해주자.

```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,avx,avx2,fma")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#include <bits/stdc++.h>
#include <ext/rope>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;

using ll = long long;
using pii = pair<int, int>;
using ti3 = tuple<int, int, int>;
using vi = vector<int>;
using vvi = vector<vi>;

constexpr int INF = int(1 << 30);
constexpr int NINF = -int(1 << 30);

int n,m;

struct unionfind{
	vi p;
	unionfind(int n):p((n << 1) + 1){
		iota(p.begin(), p.end(), 0);
	}
	int Find(int x){ return x == p[x] ? x : p[x] = Find(p[x]);}
	bool Union(int a, int b){
		a = Find(a),b = Find(b);
		if(a == b) return 0;
		p[b] = a; return 1;
	}
};

void solve(){
	cin >> n >> m;
	unionfind uf(n + 1);
	auto nt = [&](int x){ return x + n; };
	for(int i = 0; i < m; i++){
		char c; int a,b; cin >> c >> a >> b;
		if(c == 'S'){
			uf.Union(a, b); uf.Union(nt(a), nt(b));
		}
		else{
			uf.Union(nt(a), b); uf.Union(a, nt(b));
		}
	}
	for(int i = 1; i <= n; i++){
		if(uf.Find(i) == uf.Find(nt(i))){
			cout << 0 << "\n";
			return;
		}
	}
	for(int i = 1; i <= n; i++) uf.Union(i, nt(i));
	int res = 0;
	for(int i = 1; i <= (n << 1); i++) res += (i == uf.Find(i));
	cout << '1';
	for(int i = 0; i < res; i++) cout << '0';
	cout << "\n";
}

int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int t = 1;
	//cin >> t;
	for(int tc = 1; tc <= t; tc++) solve();
}
```
