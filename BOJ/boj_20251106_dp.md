# 2025.11.06일 DP 문제 풀이

#### [Lecture Allocation](https://www.acmicpc.net/problem/25791)

$N$개의 강의가 있고 $M$명의 선생님이 최대 3개의 강의를 할 수 있을 때 $N$개의 강의를 진행하기 위해 필요한 금액의 최솟값을 구하는 문제이고 배낭문제이기 때문에 그냥 입력받으면서 DP를 돌리면 된다.
2차원으로 짜면 될 것 같은데 그냥 입력 받으면서 1차원으로 해결했다.

```cpp
int n, m;
vi D(5555, INF);

void solve(){
	ri(n, m);
	D[0] = 0;
	for(int _ = 0; _ < m; _++){
		int a,b,c; ri(a, b, c);
		auto nd = D;
		for(int j = 0; j <= n; j++){
			if(D[j] == INF) continue;
			nd[j + 1] = min<int>(nd[j + 1], D[j] + a);
			nd[j + 2] = min<int>(nd[j + 2], D[j] + b);
			nd[j + 3] = min<int>(nd[j + 3], D[j] + c);
		}
		D.swap(nd);
	}
	po(D[n]);
}
```

#### [Exact Change](https://www.acmicpc.net/problem/4190)

현재 $M$원이 주어지고 $N$개의 동전을 가지고 있을 때 $M$원 이상의 금액중 동전의 개수를 **최소화**하는 문제이다.
그냥 간단하게 동전 DP의 변형처럼 풀면 된다.
$ D[i] = i원을 만드는 경우의 수 $

```cpp
void solve(){
	int m,n; ri(m, n);
	vi D(20202, INF);
	D[0] = 0;
	for(int i = 0; i < n; i++){
		int x; ri(x);
		for(int j = 10000; j >= x; j--){
			D[j] = min<int>(D[j], D[j - x] + 1);
		}
	}
	for(int j = m; ; j++){
		if(D[j] != INF){
			po(j, D[j]);
			return;
		}
	}
}
```

#### [Hay For Sale](https://www.acmicpc.net/problem/6076)

현재 $0 ~ N$의 부피까지의 범위를 봤을 때 건초를 최대한 많이 담을 수 있게 만드는 문제이다.
그냥 0/1 냅색문제처럼 풀면 되는거고... 정답의 구간은 $[0, N]$의 범위에서 $D[i]$의 최대값을 출력하면 된다.

```cpp
void solve(){
	int n,m; ri(n, m);
	vi D(n + 1);
	vi v(m); ri(v);
	for(const auto& x : v){
		for(int j = n; j >= x; j--){
			D[j] = max<int>(D[j], D[j - x] + x);
		}
	}
	int mx = 0;
	for(int j = 0; j <= n; j++) mx = max<int>(mx, D[j]);
	po(mx);
}
```
