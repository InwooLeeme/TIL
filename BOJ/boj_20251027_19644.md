# 19644번 : 좀비 떼가 기관총 진지에도 오다니

풀면서 좀 많이 어려웠고 여러모로 감탄했던 문제.
이게 뭘까.. 계속 고민하다가 그리디일 것 같아서 거의 찍다시피 풀었다.
수평 세열 지향성 지뢰는 그리디하게 무조건 1m앞에 있는 적을 죽이는 게 최적이고,
기관총의 사거리의 합을 관리하면서 그리디하게 처리해주면 된다.
c >= 0인 경우 YES 아니면 NO

```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,avx,avx2,fma")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#include <bits/stdc++.h>
#include <ext/rope>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;

#define int int64_t

using ll = long long;
using pii = pair<int, int>;
using ti3 = tuple<int, int, int>;
using vi = vector<int>;
using vvi = vector<vi>;

constexpr int INF = int(1 << 30);
constexpr int NINF = -int(1 << 30);

int n,a,b,c;

template<typename T>
struct Fenwick1D{
    int sz;
    vector<T> tree,data;
    int lowbit(int x) const{ return x & (-x); }
    Fenwick1D(int n):sz(n),tree(sz + 1),data(sz + 1){}
    void Update(int i, T val){ // v[x] += val
        while(i <= sz){
            tree[i] += val;
            i += lowbit(i);
        }
    }
    void Set_Val(int i, T val){ // v[x] = val
        int delta = val - data[i];
        data[i] = val;
        Update(i, delta);
    }
    T Query(int idx) const{
        int ret = 0;
        int i = idx;
        while(i > 0){
            ret += tree[i];
            i -= lowbit(i);
        }
        return ret;
    }
    T Query_Range(int l, int r) const{
        return Query(r) - Query(l - 1);
    }
    T Get_Val(int i) const{ // return v[x]
        return data[i];
    }
};

void solve(){
	cin >> n >> a >> b >> c;
	Fenwick1D<int> ft(n);
	int prv = 0;
	for(int i = 1; i <= n; i++){
		int x; cin >> x;
		ft.Update(i, x - prv);
		prv = x;
	}
	for(int i = 1; i <= n; i++){
		if(ft.Query(i) <= b){
			ft.Update(i, -b); ft.Update(i + a, b);
		}
		else c--;
	}
	cout << (c >= 0 ? "YES" : "NO") << "\n";
}

int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int t = 1;
	//cin >> t;
	for(int tc = 1; tc <= t; tc++) solve();
}
```
