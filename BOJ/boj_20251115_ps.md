# [BOJ] 2025년 11월 문제풀이 (4)

### 1. [<span style="color: #435f7a;">S1</span>] [카탈란 마스터의 선분 그리기 게임](https://www.acmicpc.net/problem/27296)

- **tag** : math, geometry, game theroy

찍어서 맞췄다.
$N < 2$인 경우 항상 선공이 진다.

```cpp
void solve(){
	int n; ri(n);
	if(n < 2) po(1, 0);
	else po(0, 1);
}
```

### 2. [<span style="color: #435f7a;">S5</span>] [Step Aerobics](https://www.acmicpc.net/problem/22428)

- **tag** : implementation, simulation

맨 뒤에 글자는 같아야한다. 앞의 글자는 같으면 안된다.

```cpp
void solve(){
	int n;
	while(cin >> n and n){
		vector<string> v(n); ri(v);
		int res = 0;
		for(int i = 1; i < n; i++){
			if(v[i].back() == v[i - 1].back() and v[i].front() != v[i - 1].front()) res++,i++;
		}
		po(res);
	}
}
```

### 3. [<span style="color: #435f7a;">S3</span>] [Kick_Start](https://www.acmicpc.net/problem/23921)

- **tag** : implementation, simulation

KICK과 START는 겹치지 않는 것을 이용해서 START가 나오기 전에 KICK이 얼마나 나왔는지 횟수를 더해주면 된다.

```cpp
void solve(){
	string s; ri(s);
	int res = 0, kcnt = 0;
	for(int i = 0; i < si(s); i++){
		if(i > 3 and s.substr(i - 4, 5) == "START") res += kcnt;
		else if(i > 2 and s.substr(i - 3, 4) == "KICK") kcnt++;
	}
	po(res);
}
```

### 4. [<span style="color: #ec9a00;">G2</span>] [ERP](https://www.acmicpc.net/problem/9911)

- **tag** : implementation, dijkstra

각 상태를 `(x, y,방향)`으로 놓은 다음에 문제에서 요구한대로 그대로 구현해주면 된다.

```cpp
int n,m;
string v[33];
bool bound(int x, int y){ return x < 0 or x >= n or y < 0 or y >= m; }

void solve(){
	ri(n, m);
	for(int i = 0; i < n; i++) ri(v[i]);
	vvvi dist(n + 1, vvi(m + 1, vi(4, INF)));
	minpq<array<int, 4>> pq;
	[&](){
		for(int i = 0; i < n; i++) for(int j = 0; j < m; j++){
			if(v[i][j] == '.') continue;
			if(string("WSEN").find(v[i][j]) != -1){
				int d = string("WSEN").find(v[i][j]);
				v[i][j] = '#';
				pq.push({dist[i][j][d] = 0, d, i, j});
				return;
			}
		}
	}();
	while(si(pq)){
		auto [cdist, dir, x, y] = pq.top(); pq.pop();
		if(dist[x][y][dir] < cdist) continue;
		if(v[x][y] == 'F'){
			po(cdist);
			return;
		}
		int cnt = 0;
		for(auto& nd : {dir, (dir + 1) % 4, (dir + 3) % 4}){
			int nx = x + dx[nd], ny = y + dy[nd];
			if(bound(nx, ny) or v[nx][ny] == '.') continue;
			auto ncost = cdist + (nd != dir ? (nd == ((dir + 1) % 4) ? 1 : 5) : 0);
			cnt++;
			if(dist[nx][ny][nd] > ncost){
				pq.push({dist[nx][ny][nd] = ncost, nd, nx, ny});
			}
		}
		if(!cnt){
			int nd = (dir + 2) % 4;
			int ncost = cdist + 10;
			int nx = x + dx[nd], ny = y + dy[nd];
			pq.push({dist[nx][ny][nd] = ncost, nd, nx, ny});
		}
	}
}
```

### 5. [<span style="color: #27e2a4;">P4</span>] [원 전문가 진우](https://www.acmicpc.net/problem/16481)

[루리에의 정리](https://m.blog.naver.com/mathpeakedu/221658345406)를 이용해주면 풀 수 있다고 한다...

```cpp
void solve(){
	double a,b,c; ri(a, b, c);
	po(a * b * c / ((b * c) + (a * c) + (a * b)));
}
```
