# [BOJ] 2025년 11월 문제풀이 (2)

### 1. [<span style="color: #435f7a;">S2</span>] [Codepowers](https://www.acmicpc.net/problem/26007)

- **tag** : prefix sum

$K$보다 작은 값에 대해서 누적합을 만든 다음에 $Q$개의 쿼리를 $O(1)$에 처리해주면 된다.

```cpp
int N, Q, K, X;
int v[1 << 17];

void solve(){
	ri(N, Q, K, X);
	int prv = X;
	for(int i = 1; i <= N; i++){
		int x; ri(x);
		prv += x;
		//debug(prv);
		if(prv < K) v[i]++;
	}
	for(int i = 1; i <= N + 1; i++) v[i] += v[i - 1];
	while(Q--){
		int l,r; ri(l, r); --l, --r;
		po(v[r] - v[l]);
	}
}
```

### 2. [<span style="color: #ec9a00;">G3</span>] [팔정도 모니터링](https://www.acmicpc.net/problem/34729)

- **tag** : math, sorting, ternary search

절댓값의 합을 구해야한다 -> 볼록한 구간이다 -> 삼분탐색을 쓰면 구할 수 있다.는 사실은 자명하다 문제에서 식을 그냥 대놓고 줬으므로 주어진 좌표를 정렬한 이후 삼분탐색으로 최소값을 구해주면 된다.

```cpp
int N, r;

void solve(){
	ri(N, r);
	vp v(N); for(auto& [a, b] : v) ri(a, b); sort(all(v));
	auto F = [&](int x, int y) -> int{
		int res = 0;
		for(const auto& [a, b] : v) res += (abs(a - x) + abs(y - b));
		return res;
	};
	auto check = [&](const int t) -> int{
		return F(t, 0) + F(0, t) + F(t, t) + F(t, -t);
	};
	int s = -r - 1, e = r + 1;
	while(s + 3 < e){
		int L = (s + s + e) / 3, R = (s + e + e) / 3;
		if(check(L) > check(R)) s = L;
		else e = R;
	}
	int mn = INF, idx = s;
	for(int i = max<int>(s, -r); i <= min<int>(e, r); i++) if(int cur = check(i); cur < mn) mn = cur, idx = i;
	po(mn);
}
```

### 3. [<span style="color: #435f7a;">S2</span>] [dongshop](https://www.acmicpc.net/problem/34706)

- **tag** : constructive

중간 행을 하나 잡고 쭉 채우면 정답을 구성할 수 있다.

```cpp
void solve(){
	int n; ri(n);
	int x = n + 1 >> 1;
	for(int i = 1; i <= n; i++) po(x, i);
}
```
