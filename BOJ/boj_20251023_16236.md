# 16236번 : 아기 상어

BFS를 이용해서 현재 아기상어의 위치와 크기값을 관리해주면서 아기상어의 움직임을 구현하면 된다

```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,avx,avx2,fma")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#include <bits/stdc++.h>
#include <ext/rope>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;

#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define fi first
#define se second
#define pb push_back
#define si(x) (int)x.size()

using ll = long long;
using pii = pair<int, int>;
using ti3 = tuple<int, int, int>;
using vi = vector<int>;
using vvi = vector<vi>;

const int PRECISION = 0;
const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};
const int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1}, ddy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
constexpr ll INF = 1LL << 30;
constexpr ll NINF = -INF;

int n, board[33][33];
bool bound(int x, int y){ return x < 0 or x >= n or y < 0 or y >= n; }
int sx = -1,sy = -1,sz = 2,res,eat_cnt;
int dist[33][33];

int Move(int x, int y){
    queue<ti3> q;
    memset(dist, -1, sizeof(dist));
    q.push({sz, x, y}); dist[x][y] = 0;
    while(q.size()){
        auto [shark_size, x, y] = q.front(); q.pop();
        for(int d = 0; d < 4; d++){
            auto nx = x + dx[d], ny = y + dy[d];
            if(bound(nx, ny)) continue;
            if(board[nx][ny] > shark_size) continue;
            if(dist[nx][ny] != -1) continue;
            dist[nx][ny] = dist[x][y] + 1; q.push({shark_size, nx, ny});
        }
    }
    struct node{ int di, x, y; };
    vector<node> v;
    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){
        if(dist[i][j] == -1 or board[i][j] >= sz or !board[i][j]) continue;
        v.push_back({dist[i][j], i, j});
    }
    if(v.empty()) return 0;
    sort(all(v), [&](node& a, node& b){
        return a.di == b.di ? (a.x == b.x ? a.y < b.y : a.x < b.x) : a.di < b.di;
    });
    auto [di, r, c] = v[0];
    res += di;
    sx = r, sy = c;
    eat_cnt++;
    board[r][c] = 0;
    if(eat_cnt == sz){
        sz++;
        eat_cnt = 0;
    }
    return 1;
}

void solve(){
    cin >> n;
    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++){
        cin >> board[i][j];
        if(board[i][j] == 9) sx = i,sy = j, board[i][j] = 0; 
    }
    while(Move(sx, sy)){}
    cout << res << "\n";
}

void Main(){
    int t = 1; 
    //cin >> t;
    while(t--) solve();
    /* for(int tc = 1; tc <= t; tc++){
    cout << "Case #" << tc << ": "; solve();
    } */
}

int32_t main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cout.setf(ios::fixed); cout.precision(PRECISION);
    Main();
    return 0;
}
```
